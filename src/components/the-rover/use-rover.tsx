/**
 * This file is open-source. This means that it can be reproduced in whole
 * or in part, stored in a retrieval system transmitted in any form, or by
 * any means electronic with my prior permission as an author and owner
 * Please refer to the terms of the license agreement in the root of the project
 *
 * (c) 2021 joaodias.me
 */
import { useRef, useCallback, useContext, RefObject, KeyboardEvent } from "react";
import { useSafeLayoutEffect } from "../../hooks/index";
import { RoverContext } from "./rover-provider/context";

/**
 * Generates a Random Index
 *
 * @param {string} prefix
 * @returns
 */
function generateRandomIndex(prefix: string) {
	const randomNumber = Number(String(Math.random()).slice(2)) + Date.now() + Math.round(performance.now());
	return prefix + randomNumber.toString(36);
}

/**
 * Generates a unique ID.
 * If prefix is given, the ID is appended to it.
 *
 * @export
 * @param {string} [prefix="_"]
 * @returns {string}
 */
export function uniqueId(prefix = "_"): string {
	return generateRandomIndex(prefix);
}

type TabDirection = "NEXT" | "PREVIOUS";

// domElementRef:
//   - a React DOM element ref of the DOM element that is the focus target
//   - this must be the same DOM element for the lifecycle of the component
// disabled:
//   - can be updated as appropriate to reflect the current enabled or disabled
//     state of the component
// id:
//   - an optional ID that is the unique ID for the component
//   - if provided then it must be a non-empty string
//   - if not provided then one will be autogenerated
// The returned callbacks handleOnKeyPress and handleClick are stable.
export default function useRover<T>(
	domElementRef: RefObject<T | any>,
	disabled: boolean,
	id?: string,
): [number, boolean, (event: KeyboardEvent<T | any>) => void, () => void] {
	const tabIndexId = useRef(id || uniqueId("rat-rover-index_"));
	const { state, dispatch } = useContext(RoverContext);

	useSafeLayoutEffect(() => {
		if (disabled) {
			return;
		}

		const id = tabIndexId.current;

		dispatch({
			type: "REGISTER",
			payload: { id, domElementRef },
		});

		// eslint-disable-next-line consistent-return
		return (): void => {
			dispatch({
				type: "UNREGISTER",
				payload: { id },
			});
		};
	}, [disabled]);

	const handleOnKeyPress = useCallback(
		(event: KeyboardEvent<T | any>) => {
			const payload = { id: tabIndexId.current };

			function getDirection(event: KeyboardEvent<T | any>): TabDirection | null {
				if (state.direction === "horizontal" || state.direction === "both") {
					if (event.key === "ArrowLeft") {
						return "PREVIOUS";
					}
					if (event.key === "ArrowRight") {
						return "NEXT";
					}
				}
				if (state.direction === "vertical" || state.direction === "both") {
					if (event.key === "ArrowUp") {
						return "PREVIOUS";
					}
					if (event.key === "ArrowDown") {
						return "NEXT";
					}
				}

				return null;
			}

			const direction = getDirection(event);

			if (direction === "PREVIOUS") {
				dispatch({
					type: "TAB_TO_PREVIOUS",
					payload,
				});
			} else if (direction === "NEXT") {
				dispatch({
					type: "TAB_TO_NEXT",
					payload,
				});
			} else if (event.key === "Home") {
				dispatch({ type: "TAB_TO_FIRST" });
			} else if (event.key === "End") {
				dispatch({ type: "TAB_TO_LAST" });
			}

			event.preventDefault();
		},
		[state.direction, dispatch],
	);

	const handleClick = useCallback(() => {
		dispatch({
			type: "CLICKED",
			payload: { id: tabIndexId.current },
		});
	}, [dispatch]);

	const selected = !disabled && tabIndexId.current === state.selectedId;
	const tabIndex = selected ? 0 : -1;
	const focused = selected && state.lastActionOrigin !== null;

	return [tabIndex, focused, handleOnKeyPress, handleClick];
}
